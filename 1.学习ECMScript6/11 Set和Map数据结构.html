<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>set和Map数据结构</title>
</head>
<body>

</body>
</html>
<script>
    //Set数据结构，类似于数组，但是成员的值都是唯一的
    const s = new Set();
    [2,3,5,4,5,2,2].forEach(x=>s.add(x));
    for(let i of s){
        console.log(i);
    }
    //2,3,5,4
    //通过add方法向set结构加入成员，结果表明SET结构不会添加重复的值

    //Set函数接收一个数组(类似数组的对象)作为参数，用来初始化
    var set = new Set([1,2,3,4]);
    var items = new Set([1,2,3,4,5,5,5,5]);
    function div(){
        return [...document.querySelector('div')];
    }
    var set = new Set(div());
    set.size();

    Set.prototype.constructor //Set的构造函数
    Set.prototype.size //Set实例的成员总数

    //set实例的方法
    //set.add(value)
    //set.delete(value)
    //set.has(value)
    //set.clear()

    let s = new Set();
    s.add(1).add(2).add(2);
    s.size
    s.has(1)
    s.delete(1)
    s.has(2);

    //Set的遍历方法
    //set.keys() 返回键名
    //set.valeus() 返回键值
    //set.entries() 返回键值对
    //set.forEach() 使用回调函数遍历每个成员

    let set = new Set(['red','green','blue']);
    for(let item of set.keys()){
        console.log(item);
    }
    for(let item of set.values()){
        console.log(item);
    }
    //Set没有键名，所以keys和values方法的行为完全一致
    for(let item of set.entries()){
        console.log(item);
    }
    //forEach方法没有返回值
    let set = new Set([1,2,3]);
    set.forEach((value,key)=>console.log(value * 2));
    //2
    //4
    //6


    //weakSet
    //这个成员只能是对象，而不能是其他类型的值
    var a = [[1,2],[3,4]];
    var ws = new WeakSet(a);

    //weakSet.prototype.add(value)
    //weakSet.prototype.delete(value)
    //weakSet.prototype.has(value)
    var ws = new WeakSet();
    var obj = {};
    var foo = {};
    ws.add(window);
    ws.add(obj);

    const foos = new WeakSet();
    class Foo{
        constructor(){
            foos.add(this);
        }
        method(){
            if(!foos.has(this)){
                throw new TypeError('Foo.prototype.method 只能在foo实例上调用');
            }
        }
    }

    //Map解决了以往的对象只能用字符串作为键名的问题
    var m = new Map();
    var o = {p:'hello world'};
    m.set(o,'content');
    m.get(o);//content

    //接收参数
    var map = new Map([
        ['name','张三'],
        ['title','Author']
    ]);
    map.size //2
    map.has('name');
    map.get('name');//张三

    //注意
    var map = new Map();
    var k1 = ['a'];
    var k2 = ['a'];
    map.set(k1,111).set(k2,222);
    map.get(k1)//111
    map.get(k2)//222
    //map的健实际是跟内存地址绑定的，只要内存地址不同，就可以
    //视为两个键.
    //如果map的健是一个简单类型的值(数字，字符串，布尔值)
    //只要两个值严格相等，map将其视为一个键
    let map = new Map();
    map.set(NaN,123);
    map.get(NaN);
    map.set(-0,123);
    map.get(+0) // 123

    //属性和方法
    //map.size
    //map.set(key,value)
    var m = new Map();
    m.set('edition',6);//键是字符串
    m.set(262,'standard')//键是数值
    m.set(undefined,'nah')
    //map.get(key)
    //map.has(key)
    //map.delete(key)
    //map.clear()

    //遍历方法
    //map.keys() 返回键名
    //map.values() 返回键值
    //map.entries() 返回所有成员
    //forEach() 遍历Map的所有成员

    let map = new Map([
        ['F', 'no'],
        ['T',  'yes'],
    ]);

    for (let key of map.keys()) {
        console.log(key);
    }
    // "F"
    // "T"

    for (let value of map.values()) {
        console.log(value);
    }
    // "no"
    // "yes"

    for (let item of map.entries()) {
        console.log(item[0], item[1]);
    }
    // "F" "no"
    // "T" "yes"

    // 或者
    for (let [key, value] of map.entries()) {
        console.log(key, value);
    }

    // 等同于使用map.entries()
    for (let [key, value] of map) {
        console.log(key, value);
    }

    //weakMap
    //同样，也只接受对象作为键名
    var wm = new WeakMap();
    var element = document.querySelector('.element');
    wm.set(element,'Original');
    wm.get(element)//original
    //如果删除了
    element.parentNode.removeChild(element);
    element = null;
    wm.get(element) //undefined
    //没有遍历操作，也没有SIZE属性
    //无法清空，不支持clear方法
    //只有get(),set(),has(),delete()方法





</script>