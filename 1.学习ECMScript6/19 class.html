<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>
<script>
    //类的概念的引入
    class Point {
        constructor(x,y){
            this.x = x;
            this.y = y;
        }
        toString(){
            return '(' + this.x + ',' + this.y + ')';
        }
    }
    //如何在类中创建私有方法，推荐做法
    const bar = Symbol('bar');
    const snaf = Symbol('snaf');

    export default class myClass{

        // 公有方法
        foo(baz) {
            this[bar](baz);
        }

        // 私有方法
        [bar](baz) {
            return this[snaf] = baz;
        }

        // ...
    };

    //class的继承
    class ColorPoint extends Point {
        constructor(x, y, color) {
            super(x, y); // 调用父类的constructor(x, y)
            this.color = color;
        }

        toString() {
            return this.color + ' ' + super.toString(); // 调用父类的toString()
        }
    }
    //派生类必须在constructor中调用super方法，否则会报错
    //这是因为派生类没有自己的this对象，而是继承父类的this对象
    //然后对其进行加工，如果不调用super方法，子类就得不到this对象




    //类的prototype属性和__proto__属性
    class A {

    }
    class B extends A {

    }
    //派生类的原型指向基类
    B.__proto__ === A //true
    //派生类原型的原型指向基类的原型
    B.prototype.__proto__ == A.prototype

    //类的继承原理
    class A {

    }
    class B {

    }
    //B的实例继承A的实例
    Object.setPrototypeOf(B.prototype,A.prototype);
    const b = new B();
    //B的实例继承A的静态属性
    Object.setPrototypeOf(B,A);
    const b = new B();
    Object.setPrototypeOf = function (obj, proto) {
        obj.__proto__ = proto;
        return obj;
    }

    //super关键字
    //1.作为函数调用时候，代表父类的构造函数
    class A{}
    class B extends A {
        constructor (){
            super();
        }
    }
    //这里要注意的是,super虽然代表了父类A的构造函数
    //但是返回的是子类的B的实例,即super内部的this指的是B
    //因此super()在这里相当于a.prototype.constructor.call(this)

    //2.作为对象时，指向父类的原型对象
    class A {
        p(){
            return 2;
        }
    }
    class B extends A {
        constructor(){
            super();
            console.log(super.p()); //2
        }
    }
    let b = new B();
    //相当于a.prototype.p()
    //这里需要注意的是,super不能获取非原型的方法和属性


    //如果你通过super去调用父类方法的时候，super会绑定子类的this
    class A {
        constructor(){
            this.x = 1;
        }
        print(){
            console.log(this.x);
        }
    }
    class B extends A {
        constructor(){
            super();
            this.x = 2;
            //也可以使用
            //super.x = 3;
            //同样是指向this
        }
        m(){
            super.print();
        }
    }
    let b = new B ();
    b.m()//2

    //这是个实例的__proto__属性,为的就是对比一下.
    function animal(){
        this.name = '动物';
    }
    animal.prototype.run = function(){
        console.log(this.name + 'running');
    }
    var obj = new animal();
    //console.dir(obj.__proto__);
    //console.log(animal.prototype);
    //console.log(animal.prototype.constructor === animal);

    //对比下类实例的__proto__属性
    var p1 = new Point(2,3);
    var p2 = new ColorPoint(2,3,'red');
    p2.__proto__ === p1.__proto__; //false
    p2.__proto__.__proto__ === p1.__proto__ //true

    //class的extend除了可以继承类之外，也可以继承原生的数据类型
    //ES6允许继承原生构造函数，因为是先创建父类,然后通过修改this
    //ES5中是先创建子类的this,再将父类的属性添加到子类上.

    //下面是一个继承Array的例子
    class VersionedArray extends Array {
        constructor() {
            super();
            this.history = [[]];
        }
        commit() {
            this.history.push(this.slice());
        }
        revert() {
            this.splice(0, this.length, ...this.history[this.history.length - 1]);
        }
    }

    var x = new VersionedArray();

    x.push(1);
    x.push(2);
    x // [1, 2]
    x.history // [[]]

    x.commit();
    x.history // [[], [1, 2]]
    x.push(3);
    x // [1, 2, 3]

    x.revert();
    x // [1, 2]


    //class内部可以使用get和set关键字，对某个属性设置存储
    //函数和取值函数，拦截该属性的存储行为
    class MyClass {
        constructor() {
            // ...
        }
        get prop() {
            return 'getter';
        }
        set prop(value) {
            console.log('setter: '+value);
        }
    }

    let inst = new MyClass();

    inst.prop = 123;
    // setter: 123

    inst.prop
    // 'getter'

    //类中的静态方法
    class foo{
        static classMethod(){
            return 'hello';
        }
    }
    foo.classMethod();
    var foo1 = new foo();
    foo.classMethod(); // typeError


    //父类的静态方法，可以被子类继承
    class Foo {
        static classMethod() {
            return 'hello';
        }
    }

    class Bar extends Foo {
    }

    Bar.classMethod(); // 'hello'

    //也可以从super对象上调用
    class Foo {
        static classMethod() {
            return 'hello';
        }
    }

    class Bar extends Foo {
        static classMethod() {
            return super.classMethod() + ', too';
        }
    }

    Bar.classMethod();

    //ES7中有一个关于静态属性的提案


    //new.target属性
    //new命令引入了一个new.target属性
    //在构造函数中，返回new命令作用于的那个构造函数
    //如果构造函数不是通过new命令调用的,new.target返回undefined

    function Person(name) {
        if (new.target !== undefined) {
            this.name = name;
        } else {
            throw new Error('必须使用new生成实例');
        }
    }

    // 另一种写法
    function Person(name) {
        if (new.target === Person) {
            this.name = name;
        } else {
            throw new Error('必须使用new生成实例');
        }
    }

    var person = new Person('张三'); // 正确
    var notAPerson = Person.call(person, '张三');  // 报错


    //如果在class内部调用new.target,返回当前的class
    class Rectangle {
        constructor(length,width){
            console.log(new.target === Rectangle);
            this.length = length;
            this.width = width;
        }
    }
    var obj = new Rectangle(5,5);//输出true

    //利用这个特点，可以写出不能独立使用、必须继承后才能使用的类
    class Shape {
        constructor() {
            if (new.target === Shape) {
                throw new Error('本类不能实例化');
            }
        }
    }

    class Rectangle extends Shape {
        constructor(length, width) {
            super();
            // ...
        }
    }

    var x = new Shape();  // 报错
    var y = new Rectangle(3, 4);  // 正确






</script>