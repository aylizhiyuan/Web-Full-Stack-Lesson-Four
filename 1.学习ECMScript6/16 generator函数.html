<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>
<script>
    //形式上，generator函数
    // function 关键字与函数名之间有一个星号
    // 二是，函数体内部使用yield语句，定义不同的内部状态
    function * helloworldGenerator(){
        yield 'hello';
        yield 'world';
        return 'ending';
    }
    var hw = helloworldGenerator();
    //这个函数并不执行，返回的也不是函数运行的结果，而是
    //一个指向内部状态的指针对象,iterator Object
    //下一步，调用next方法，是的指针移向下一个状态.
    hw.next()
    // { value: 'hello', done: false }

    hw.next()
    // { value: 'world', done: false }

    hw.next()
    // { value: 'ending', done: true }

    hw.next()
    // { value: undefined, done: true }

    //总结一下，调用generator函数，返回一个遍历器的对象
    //代表generator函数的内部指针，以后每次调用遍历器的
    //next方法，就会返回一个有着value和done属性的对象.
    //value代表当前内部状态的值,是yield语句后面那个表达式的值
    //done表示是否遍历结束

    //实例
    var arr = [1,[[2,3],4],[5,6]];
    var flat = function * (a){
        var length = a.length;
        for(var i=0;i<length;i++){
            var item = a[i];
            if(typeof item !== 'number'){
                yield * flat(item);
            }else{
                yield item;
            }
        }
    }
    //for of 会自动调用next方法
    for(var f of flat(arr)){
        console.log(f);
    }

    //可以用Generator作为iterator的接口
    var myIterable = {};
    myIterable[Symbol.iterator] = function*(){
        yield 1;
        yield 2;
        yield 3;
    }
    [...myIterable] // [1,2,3]

    //next方法可以接收参数
    //yield本社没有返回值，或者说是undefined,next方法可以带一个参数
    //该参数就会被当做上一个yield语句的返回值.
    function * f(){
        for(var i=0;true;i++){
            var reset = yield i;
            if(reset){
                i = -1;
            }
        }
    }
    var g = f();
    g.next() //{value:0,done:false}
    g.next() //{value:1,done:false}
    g.next(true) // {value:0,done:false}


    //再看一个例子加深印象
    function * foo(x){
        var y = 2 * (yield (x + 1));
        var z = yield (y / 3);
        return (x+y+z);
    }
    var a = foo(5);
    a.next() // Object{value:6, done:false}
    a.next() // Object{value:NaN, done:false}
    a.next() // Object{value:NaN, done:true}

    var b = foo(5);
    b.next() // { value:6, done:false }
    b.next(12) // { value:8, done:false }
    b.next(13) // { value:42, done:true }

    //使用for of 就不用再使用next方法了

    //综合使用案例
    function * objectEntries(obj){
        let propKeys = Reflect.ownKeys(obj);
        for(let propKey of propKeys){
            yield [propKey,obj[propKey]];
        }
    }
    let jane = { first: 'Jane', last: 'Doe' };

    for (let [key, value] of objectEntries(jane)) {
        console.log(`${key}: ${value}`);
    }
    // first: Jane
    // last: Doe

    //或者是添加到Symbol.iterator上去
    function* objectEntries() {
        let propKeys = Object.keys(this);

        for (let propKey of propKeys) {
            yield [propKey, this[propKey]];
        }
    }

    let jane = { first: 'Jane', last: 'Doe' };

    jane[Symbol.iterator] = objectEntries;

    for (let [key, value] of jane) {
        console.log(`${key}: ${value}`);
    }
    // first: Jane
    // last: Doe

    //Generator函数返回的遍历器对象中有一个throw方法
    //可以在函数体外抛出错误,然后在generator函数体内捕获
    var g = function *(){
        try{
            yield;
        }catch(e){
            console.log('内部捕获',e);
        }
    }
    var i = g();
    i.next();

    try {
        i.throw('a');
        i.throw('b');
    }catch(e){
        console.log('外部捕获',e);
    }
    //第一次被内部的catch捕获,内部捕获 a
    //第二次被外部的catch捕获,外部捕获 b

    //再看一个例子
    var gen = function * gen(){
        try {
            yield console.log('a');
        }catch(e){

        }
        yield console.log('b');
        yield console.log('c');
    }
    var g = gen();
    g.next(); //a
    //g.throw被捕获以后，自动执行了一次next方法
    //打印了b
    g.throw() //b
    g.next() //c

    //总结,generator函数体外抛出的错误，可以在函数体内捕获
    //generator函数内体抛出的错误,也可以被函数体外的catch捕获
    function * foo(){
        var x = yield 3;
        var y = x.toUpperCase();
        yield y;
    }
    var it = foo();
    it.next(); // {value:3}
    try {
        it.next(42);
    }catch(err){
        console.log(err);
    }

    //Generator.prototype.return ()
    //可以返回给定的值,并且终结遍历函数
    function * gen(){
        yield 1;
        yield 2;
        yield 3;
    }
    var g = gen();
    g.next()        // { value: 1, done: false }
    g.return('foo') // { value: "foo", done: true }
    g.next()        // { value: undefined, done: true }


    //yield*语句
    //用于在一个generator函数内部调用另一个generator函数
    //从语法的角度看，如果yield命令后边跟的是一个遍历器对象
    //需要在yield命令后面加上星号，表名它返回的是一个遍历器对象

    //实际上，任何数据结构只要有Iterator接口，就可以被yield * 遍历
    let read = (function* () {
        yield 'hello';
        yield* 'hello';
    })();

    read.next().value // "hello"
    read.next().value // "h"

    //return的又一个作用
    //可以向代理它的generator函数返回数据
    function * foo(){
        yield 2;
        yield 3;
        return 'foo';
    }
    function * bar(){
        yield 1;
        var v = yield * foo();
        console.log('v'+ v);
        yield 4;
    }
    var it = bar();
    it.next()
    // {value: 1, done: false}
    it.next()
    // {value: 2, done: false}
    it.next()
    // {value: 3, done: false}
    it.next();
    // "v: foo"
    // {value: 4, done: false}
    it.next()
    // {value: undefined, done: true}


    //应用
    //1.异步操作的同步化表达
    //暂停执行的效果，意味着可以把异步操作写在yield语句里面
    //等到调用next方法时候再往后执行
    function* loadUI() {
        showLoadingScreen();
        yield loadUIDataAsynchronously();
        hideLoadingScreen();
    }
    var loader = loadUI();
    // 加载UI
    loader.next()

    // 卸载UI
    loader.next()

    //第一次调用loadUI,并不会执行，仅仅返回一个遍历器
    //调用next方法的时候则会调用loading页面
    //再次调用的时候隐藏loading页面.

    //2.控制流管理












</script>