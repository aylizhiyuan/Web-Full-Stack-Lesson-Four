<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>let,const</title>
    <script src="../../第三阶段---社区系统项目/routes/message.js"></script>
</head>
<body>

</body>
</html>
<script>

    /*{
        let a = 10;
        var b = 1;
    }
    console.log(b);
    //全局的变量都会自动挂载到window上
    console.log(window.b);
    console.log(a);*/

    //很适合用在for循环中
    var a = [];
    for(var i=0;i<10;i++){
        a[i] = function(){
            console.log(i);
        }
    }
    //a[6](); //10

    var a = [];
    for(let i=0;i<10;i++){
        a[i] = function(){
            console.log(i);
        }
    }
    //a[6]() //6
    //在var中的i是一个全局的变量，每次i的值都会被累加，等到调用a[6](),i的值就已经变成了10
    //但是在let中i就是单独存在于()作用域中，每次循环实际上创建的都是一个新的let变量,每次循环i的值都会自动生成一个.


    // 先声明后使用，在ES6中非常的重要
    //var 的情况
    /*console.log(foo);
    var foo = 2;
    //let 的情况
    console.log(bar);
    let bar = 2; //报错*/

    /*var tmp = 123;
    if(true){
        tmp = 'abc'; //局部的tmp在未声明前使用了
        let tmp;
    }*/

    //函数的提升
    //函数在ES5的标准中是可以被提升的
    //但是在ES6的标准中是不允许这样的
    (function(){
        f();
        function f(){
            alert(1);
        }
    })();

    //do表达式
   /* let x = do {
        let t = f();
        t * t + 1;
    }*/
    //变量X会得到整个块级作用域的返回值

    //const和let类似，也有代码块作用域
    //但是，const的值一旦声明不能改变，且在声明的时候就应该给它具体的值
    const PI = 31415;

    //对于复合类型的变量，变量名不指向数据，而是指向数据的地址
    //所以这个时候，使用常量就必须要非常的小心了
    const foo = {};
    foo.prop = 13;
    foo.prop // 13
    //foo = {} //会造成错误,因为你改变了地址



    //顶层window对象和全局变量是等价的
    window.a = 1;
    a //1
    a = 2;
    window.a // 2
    //设计败笔

    //新的标准中，let,const,class声明的全局变量，不再属于window
    //但是用var ,function 的依然是属于window对象.























</script>