<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>异步的简单概念梳理</title>
</head>
<body>

</body>
</html>
<script>
    //所谓的异步，简单说是一个任务分成两段，先执行一段，然后转而执行其他的任务，等做好了准备，再回头执行第二段

    //JS中常见的异步情况：
    //1.AJAX
    //2.image标签，script标签,ifram标签
    //3.setTimeout,setInterval
    //4.CSS3 transition/animation
    //5.postMessage
    //6.web workers
    //7.web sockets
    //在我的理解中，任何在未来不确定的时间发生的事情都可以理解为异步
    //应该把非常耗时的任务变成异步操作，这样，不会影响浏览器的性能.

    //1.回调函数模式
    //假设有两个函数f1,f2,后者等待前者的执行结果，但是f1又比较耗时
    //这种情况下，可以考虑改写f1,把f2写成f1的回调函数
    function f1(callback){
        setTimeout(function(){
            // f1的任务代码
            callback();
        },1000)
    }
    //这么做的好处是利用回调函数这种，将代码变成了f1(f2)
    //通过将f1操作变成异步，大大增加了代码的性能.
    //这种只适合于在 同步 ----> 异步 的情况,不能用来管理天生就是异步的操作
    //感觉本质是这样的你想让别人的代码执行你的代码，而别人的代码你又不能动
    /*我们对回调函数的使用无非是对函数指针的应用，函数指针的概念本身很简单，但是把函数指针应用于回调函数就体现了一种解决问题的策略，一种设计系统的思想。
    在解释这种思想前我想先说明一下，回调函数固然能解决一部分系统架构问题但是绝不能再系统内到处都是，如果你发现你的系统内到处都是回调函数，那么你一定要重构你的系统。回调函数本身是一种破坏系统结构的设计思路，回调函数会绝对的变化系统的运行轨迹，执行顺序，调用顺序。回调函数的出现会让读到你的代码的人非常的懵头转向。
    那么什么是回调函数呢，那是不得以而为之的设计策略，想象一种系统实现：在一个下载系统中有一个文件下载模块和一个下载文件当前进度显示模块，系统要求实时的显示文件的下载进度，想想很简单在面向对象的世界里无非是实现两个类而已。但是问题恰恰出在这里，显示模块如何驱动下载进度条？显示模块不知道也不应该知道下载模块所知道的文件下载进度（面向对象设计的封装性，模块间要解耦，模块内要内聚），文件下载进度是只有下载模块才知道的事情，解决方案很简单给下载模块传递一个函数指针作为回调函数驱动显示模块的显示进度。
    在面向对象的世界中这样的例子还真不少，造成这样的问题的根源，相信大家已经从上面的叙述中体会到了，就是面向对象的程序设计思想，就是设计模式中要求的模块独立性，高内聚低耦合等特性。
    封装变化的编程策略给编程人员第一位的指导思想就是面向接口编程米，即设计模式中提到的面向虚拟编程而不是面向实现。这样的编程思想极大地革新了编程世界，可以说没有这一原则就没有面向对象的程序设计，这一原则给程序设计一种指导思想即如何更高的将现实模型映射成程序模型。这样的设计思想在极大地催生高度独立性模块的同时削弱了模块间的协作性，也就是耦合性，它使得模块间更多的从事着单向的调用工作，一个模块需要某种服务就去找另一个模块，这使得程序呈现出层次性，高层通过接口调用底层，底层提供服务。但是现实世界中严格遵循现层次特性的系统是很少见的，绝对的MVC是不存在的，因为更多的模块要求通并协作，可见没有耦合就没有协作没有好的调用关系，耦合真的不是错。
    既然我们需要模块间的协作，同时我们又厌恶的摒弃模块间你中有我我中有你的暧昧关系那如何生成系统呢，答案是函数指针（不一定一定是函数指针）也就是使用回调的方式。如果一个对象关心另一个对象的状态变化那么给状态的变化注册回调函数让它通知你这类状态的改变，这样在封装了模块变化的同时实现了模块间的协作关系另辟独径的给对象解耦。
    */

    //2.事件监听
    //任务的执行不取决于代码的顺序，而是取决于某个事件是否发生
    event.on('done',f2);
    function f1 (){
        setTimeout(function(){
            //f1的任务代码
            event.trigger('done');
        },1000)
    }

    //3.promise/A+和生成器函数
    //每一个异步任务返回一个promise对象，该对象有一个
    //then方法，允许指定回调函数
    f1().then(f2);
    function f1(){
        var dfd = $.Deferred();
        setTimeout(function(){
            //f1的任务代码
            dfd.reslove();
        },500)
        return dfd.promise;
    }

    //4.async和await





</script>